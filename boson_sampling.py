# -*- coding: utf-8 -*-
"""Boson sampling.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qReZi7lF1hnL0DuNXB54X9d5TyNPGBFb
"""

pip install strawberryfields --upgrade

!pip install xanadu-cloud-client

!xcc config set REFRESH_TOKEN "eyJhbGciOiJIUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICIwYTdjOGE5Yi1lMzdkLTQ0MzItOTU2OC0xNzI3YzEwNmYyMzEifQ.eyJpYXQiOjE3MjAzODUyNTksImp0aSI6IjdlMWM5OWM2LTFjNTAtNGY2Ny1iOWEwLTcxNzc1NmUyMDlhZSIsImlzcyI6Imh0dHBzOi8vcGxhdGZvcm0ueGFuYWR1LmFpL2F1dGgvcmVhbG1zL3BsYXRmb3JtIiwiYXVkIjoiaHR0cHM6Ly9wbGF0Zm9ybS54YW5hZHUuYWkvYXV0aC9yZWFsbXMvcGxhdGZvcm0iLCJzdWIiOiI0M2Q5NGM3NC1hYWYwLTQwNjUtOGE3MS04YjljODYxNmY3OTIiLCJ0eXAiOiJPZmZsaW5lIiwiYXpwIjoicHVibGljIiwic2Vzc2lvbl9zdGF0ZSI6IjA5ZTE3YmNjLTk4MDktNDk1YS1iYWYwLTgwOWI1MDEwNzNhMyIsInNjb3BlIjoicHVibGljLXJvbGVzIHByb2ZpbGUgZW1haWwgb2ZmbGluZV9hY2Nlc3MiLCJzaWQiOiIwOWUxN2JjYy05ODA5LTQ5NWEtYmFmMC04MDliNTAxMDczYTMifQ.WaGp-7S2KcQkM_UFoPKYTboJ-6kxiHEWOnvMSncuiME"

!xcc ping

import numpy as np

# set the random seed
np.random.seed(42)

# import Strawberry Fields
import strawberryfields as sf
from strawberryfields.ops import *

# initialize a 4 mode program
boson_sampling = sf.Program(2)

with boson_sampling.context as q:
    # prepare the input fock states
    Fock(2) | q[0]
    Fock(1) | q[1]

    # rotation gates pi/6~0.5233 and -pi/4~-0.785
    Rgate(0.5233)  | q[0]
    Rgate(-0.785) | q[1]

    # beamsplitter array for theta=pi/3 and phi=pi/2
    BSgate(1.046, 1.57)  | (q[0], q[1])

eng = sf.Engine(backend="fock", backend_options={"cutoff_dim": 7})

results = eng.run(boson_sampling)

# extract the joint Fock probabilities
probs = results.state.all_fock_probs()

# print the joint Fock state probabilities
print(probs[1,2])

prog_unitary = sf.Program(2)
prog_unitary.circuit = boson_sampling.circuit[2:]
prog_compiled = prog_unitary.compile(compiler="gaussian_unitary")

prog_compiled.print()

S = prog_compiled.circuit[0].op.p[0]
U = S[:2, :2] + 1j*S[2:, :2]
print(U)

boson_sampling = sf.Program(2)

with boson_sampling.context as q:
    # prepare the input fock states
    Fock(2) | q[0]
    Fock(1) | q[1]

    Interferometer(U) | q

boson_sampling.compile(compiler="fock").print()

print(probs[1, 2])

from thewalrus import perm

print(np.abs(perm(U[:, [0,0,1]][[0,1,1]]))**2 / 4)

BS = np.abs(perm(U[:, [0,0,1]][[0,1,1]]))**2 / 4
SF = probs[1,2]

print(100*np.abs(BS-SF)/BS)